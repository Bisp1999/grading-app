{% extends "base.html" %}
{% block title %}{{ _('Review and Adjust Grades') }}{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h2>{{ _('Review and Adjust Grades') }}</h2>
            <p class="text-muted">{{ _('Review student grades across tests and make adjustments as needed.') }}</p>
        </div>
    </div>

    <!-- Actions Section -->
    <div class="row mb-4" id="actionsSection" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5>{{ _('Actions') }}</h5>
                </div>
                <div class="card-body">
                    {% if teacher_type == 'homeroom' %}
                    <!-- Subject Filter for Homeroom Teachers -->
                    <div class="row mb-3">
                        <div class="col-md-6">
                            <label for="filter_subject" class="form-label">{{ _('Subject:') }}</label>
                            <select class="form-select" id="filter_subject" name="filter_subject" onchange="loadGradeMatrix()">
                                <option value="">{{ _('All Subjects') }}</option>
                                {% for subject in subjects %}
                                    <option value="{{ subject }}">{{ subject }}</option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                    {% endif %}
                    
                    <div class="row">
                        <!-- Test Actions -->
                        <div class="col-md-4 mb-3">
                            <h6 class="text-muted small">{{ _('Test Actions') }}</h6>
                            <div class="d-grid gap-2">
                                <button class="btn btn-outline-primary btn-sm" onclick="bellGradeTest()">
                                    <i class="fas fa-bell me-1"></i>{{ _('Bell Grade a Test') }}
                                </button>
                                <button class="btn btn-outline-primary btn-sm" onclick="changeTestWeighting()">
                                    <i class="fas fa-balance-scale me-1"></i>{{ _('Change Test Weighting') }}
                                </button>
                            </div>
                        </div>
                        
                        <!-- Student Actions -->
                        <div class="col-md-4 mb-3">
                            <h6 class="text-muted small">{{ _('Student Actions') }}</h6>
                            <div class="d-grid gap-2">
                                <button class="btn btn-outline-primary btn-sm" onclick="dealWithAbsences()">
                                    <i class="fas fa-user-times me-1"></i>{{ _('Deal with Absences') }}
                                </button>
                                <button class="btn btn-outline-primary btn-sm" onclick="reviseGrades()">
                                    <i class="fas fa-edit me-1"></i>{{ _('Revise Grades') }}
                                </button>
                            </div>
                        </div>
                        
                        <!-- Class Actions -->
                        <div class="col-md-4 mb-3">
                            <h6 class="text-muted small">{{ _('Class Actions') }}</h6>
                            <div class="d-grid gap-2">
                                <button class="btn btn-outline-primary btn-sm" onclick="exportToCSV()">
                                    <i class="fas fa-download me-1"></i>{{ _('Export CSV') }}
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Bell Grade Expanded Section (below all buttons) -->
                    <div class="row">
                        <div class="col-12" id="bellGradeContainer" style="display:none;">
                            <hr/>
                            
                            <!-- Title with blue background -->
                            <div class="bg-primary text-white py-2 px-3 mb-4">
                                <h5 class="mb-0">{{ _('Bell Grade a Test') }}</h5>
                            </div>
                            
                            <!-- Explanation text -->
                            <p class="mb-4" style="font-size: 1.1rem;">
                                {{ _("We'll provide you with 3 options of how you want the Bell Grade applied, and you'll be able to see how your students grade compared to their original scores.") }}
                            </p>
                            
                            <!-- Three option cards -->
                            <div class="row g-3 mb-4">
                                <div class="col-md-4">
                                    <div class="border rounded p-4 text-center h-100" style="background-color: #f8f9fa;">
                                        <h5 class="mb-3">{{ _('Equal Adjustment') }}</h5>
                                        <p class="mb-0">{{ _('Move all students grades equally') }}</p>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="border rounded p-4 text-center h-100" style="background-color: #f8f9fa;">
                                        <h5 class="mb-3">{{ _('Lower Boost') }}</h5>
                                        <p class="mb-0">{{ _('Greater boost to lower scores') }}</p>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="border rounded p-4 text-center h-100" style="background-color: #f8f9fa;">
                                        <h5 class="mb-3">{{ _('Typical Distribution') }}</h5>
                                        <p class="mb-0">{{ _('Tighten and lift the scores') }}</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Form section -->
                            <div id="bellGradeForm">
                                <div class="row g-3 align-items-end">
                                    <!-- Select test -->
                                    <div class="col-md-4">
                                        <label class="form-label" for="bell_test_select">{{ _('Select a test') }}</label>
                                        <select id="bell_test_select" class="form-select" onchange="onBellTestChanged()">
                                            <option value="">{{ _('Select a test...') }}</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Target class average -->
                                    <div class="col-md-4">
                                        <label class="form-label" for="bell_target_avg">{{ _('Target class avg (%%)') }}</label>
                                        <input id="bell_target_avg" type="number" class="form-control" min="0" max="100" step="0.1" placeholder="e.g. 75">
                                    </div>
                                    
                                    <!-- Generate button -->
                                    <div class="col-md-4">
                                        <button class="btn btn-primary w-100" onclick="submitBellGrading()">{{ _('Generate Options') }}</button>
                                    </div>
                                </div>
                            </div>

                            <div id="bellGradeResults" class="mt-4" style="display:none;">
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h6 class="mb-0">{{ _('Proposed Adjustments') }}</h6>
                                    <button class="btn btn-sm btn-outline-secondary" onclick="editBellGrading()">{{ _('Edit Options') }}</button>
                                </div>
                                <div class="table-responsive">
                                    <table class="table table-sm table-bordered" id="bellGradeTable" style="width: 80%;">
                                        <thead class="table-light">
                                            <tr>
                                                <th>{{ _('Student Name') }}</th>
                                                <th class="text-center">{{ _('Original Grades - baseline') }}</th>
                                                <th class="text-center">{{ _('Equal Adjustment') }}</th>
                                                <th class="text-center">{{ _('Lower Boost') }}</th>
                                                <th class="text-center">{{ _('Typical Distribution') }}</th>
                                            </tr>
                                        </thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                
                                <!-- Selection dropdown and apply button -->
                                <div class="row g-3 align-items-end mt-3">
                                    <div class="col-md-6">
                                        <label class="form-label fw-bold" for="bell_option_select">{{ _('Which option would you like to apply?') }}</label>
                                        <select id="bell_option_select" class="form-select">
                                            <option value="original">{{ _('Keep original grades') }}</option>
                                            <option value="linear">{{ _('Equal Adjustment') }}</option>
                                            <option value="sqrt">{{ _('Lower Boost') }}</option>
                                            <option value="percentage">{{ _('Typical Distribution') }}</option>
                                        </select>
                                    </div>
                                    <div class="col-md-3">
                                        <button class="btn btn-success w-100" onclick="applyBellSelection()">{{ _('Apply Changes') }}</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- No Selection Message -->
    <div class="row" id="noSelectionSection">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5>{{ _('Grade Matrix') }}</h5>
                </div>
                <div class="card-body">
                    <div class="text-center py-4">
                        <p class="text-muted">{{ _('Please select a Class and Semester to view tests.') }}</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Grade Matrix Section -->
    <div class="row" id="gradeMatrixSection" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5>{{ _('Grade Matrix') }}</h5>
                </div>
                
                <div class="card-body">
                    <div class="table-responsive" style="overflow-x: auto; max-height: 600px; overflow-y: auto;">
                        <table id="gradeMatrix" class="table table-bordered table-sm" style="min-width: 100%; white-space: nowrap;">
                            <thead id="gradeMatrixHeader" style="position: sticky; top: 0; z-index: 10; background-color: #f8f9fa;"></thead>
                            <tbody id="gradeMatrixBody"></tbody>
                            <tfoot id="gradeMatrixFooter" style="position: sticky; bottom: 0; z-index: 10; background-color: #f8f9fa;"></tfoot>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- No Data Message -->
    <div class="row" id="noDataSection" style="display: none;">
        <div class="col-12">
            <div class="alert alert-info">
                <h5>{{ _('No Data Found') }}</h5>
                <p>{{ _('No tests or grades found for the selected filters. Please adjust your filters or ensure tests have been created and grades have been entered.') }}</p>
            </div>
        </div>
    </div>
</div>

<!-- Translations for JavaScript -->
<script type="application/json" id="translations">
{
    "allClasses": {{ _('All Classes')|tojson }},
    "studentName": {{ _('Student Name')|tojson }},
    "weight": {{ _('Weight:')|tojson }},
    "total": {{ _('Total')|tojson }},
    "grandTotal": {{ _('Grand Total')|tojson }},
    "weighted": {{ _('weighted')|tojson }},
    "notGraded": {{ _('Not graded')|tojson }},
    "classAverage": {{ _('Class Average')|tojson }},
    "noDataToExport": {{ _('No data to export.')|tojson }}
}
</script>

<script>
// Store data for dynamic updates
const classroomsByGrade = {{ classrooms_by_grade|tojson|safe }};
const teacherType = {{ teacher_type|tojson|safe }};
const translations = JSON.parse(document.getElementById('translations').textContent);
let currentGradeData = null;

// --- Bell Grade Feature ---
function bellGradeTest() {
    const container = document.getElementById('bellGradeContainer');
    if (!container) return;
    container.style.display = container.style.display === 'none' ? 'block' : 'none';
    if (container.style.display === 'block') {
        populateBellTests();
    }
}

function toggleBellAdjustAvg() {
    const checked = document.getElementById('bell_option_adjust_avg').checked;
    const el = document.getElementById('bell_adjust_avg_options');
    if (checked) {
        el.classList.remove('d-none');
    } else {
        el.classList.add('d-none');
    }
}

function toggleBellBoostLow() {
    const checked = document.getElementById('bell_option_boost_low').checked;
    const el = document.getElementById('bell_boost_low_options');
    if (checked) {
        el.classList.remove('d-none');
    } else {
        el.classList.add('d-none');
    }
}

function onBellTestChanged() {
    // No longer needed - test name display removed from UI
}

function getGlobalFilterValues() {
    const className = document.getElementById('global_class_filter') ? document.getElementById('global_class_filter').value : '';
    const semester = document.getElementById('global_semester_filter') ? document.getElementById('global_semester_filter').value : '';
    const subject = (teacherType === 'homeroom') ? ((document.getElementById('filter_subject') ? document.getElementById('filter_subject').value : '') || '') : '';
    return { className, semester, subject };
}

function populateBellTests() {
    const { className, semester, subject } = getGlobalFilterValues();
    const select = document.getElementById('bell_test_select');
    if (!semester) {
        select.innerHTML = '<option value="">Please select a Semester first</option>';
        return;
    }
    const params = new URLSearchParams();
    params.append('semester', semester);
    if (className) params.append('class_name', className);
    if (subject) params.append('subject', subject);
    fetch(`/api/get_tests_for_context?${params.toString()}`)
        .then(r => r.json())
        .then(data => {
            select.innerHTML = '<option value="">Select a test...</option>';
            if (data.tests) {
                data.tests.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t.id;
                    opt.textContent = `${t.test_name} (${t.test_date})`;
                    select.appendChild(opt);
                });
            }
        })
        .catch(err => console.error('Failed to load tests for bell grading', err));
}

function submitBellGrading() {
    const testId = document.getElementById('bell_test_select').value;
    if (!testId) { alert('Please select a test'); return; }
    
    const targetAvgVal = document.getElementById('bell_target_avg').value;
    const targetAvg = targetAvgVal ? parseFloat(targetAvgVal) : null;
    const { className, semester, subject } = getGlobalFilterValues();

    if (targetAvg === null || isNaN(targetAvg) || targetAvg <= 0 || targetAvg > 100) {
        alert('Please provide a valid target average between 0 and 100');
        return;
    }

    const payload = {
        test_id: parseInt(testId),
        adjust_avg: true,
        target_avg: targetAvg,
        allow_over_100: false,
        boost_low: true,
        lowest_score: null,
        class_name: className || null,
        semester: semester || null,
        subject: subject || null
    };

    fetch('/api/bell_grade_scenarios', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    }).then(r => r.json())
      .then(data => {
        if (data.error) { alert(data.error); return; }
        // Hide form, show results
        document.getElementById('bellGradeForm').style.display = 'none';
        const results = document.getElementById('bellGradeResults');
        results.style.display = 'block';
        const tbody = document.querySelector('#bellGradeTable tbody');
        tbody.innerHTML = '';
        data.students.forEach(s => {
            const tr = document.createElement('tr');
            const fmt = (v) => (v === null || v === undefined) ? '--' : v.toFixed(1);
            tr.innerHTML = `
                <td>${s.name}</td>
                <td class="text-center">${fmt(s.original)}</td>
                <td class="text-center">${fmt(s.linear)}</td>
                <td class="text-center">${fmt(s.sqrt)}</td>
                <td class="text-center">${fmt(s.percentage)}</td>
            `;
            tbody.appendChild(tr);
        });

        // Compute column averages and update table headers
        const vals = {
          original: [],
          linear: [],
          percentage: [],
          sqrt: []
        };
        data.students.forEach(s => {
          if (typeof s.original === 'number') vals.original.push(s.original);
          if (typeof s.linear === 'number') vals.linear.push(s.linear);
          if (typeof s.percentage === 'number') vals.percentage.push(s.percentage);
          if (typeof s.sqrt === 'number') vals.sqrt.push(s.sqrt);
        });
        const avg = arr => arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length) : null;
        const avgs = {
          original: avg(vals.original),
          linear: avg(vals.linear),
          percentage: avg(vals.percentage),
          sqrt: avg(vals.sqrt)
        };
        const headerCells = document.querySelectorAll('#bellGradeTable thead th');
        // headerCells: [0]=name, [1]=original, [2]=linear, [3]=sqrt, [4]=percentage
        const setAvg = (idx, value) => {
          const th = headerCells[idx];
          if (!th) return;
          // Get original header text (without any previous average)
          const originalText = th.getAttribute('data-original-text') || th.textContent.split('\n')[0].trim();
          if (!th.getAttribute('data-original-text')) {
            th.setAttribute('data-original-text', originalText);
          }
          if (value === null) {
            th.innerHTML = originalText;
          } else {
            th.innerHTML = `${originalText}<br><span class="text-muted small">Avg = ${value.toFixed(1)}%</span>`;
          }
        };
        setAvg(1, avgs.original);
        setAvg(2, avgs.linear);
        setAvg(3, avgs.sqrt);
        setAvg(4, avgs.percentage);
      })
      .catch(err => {
        console.error('Bell grading failed', err);
        alert('Error generating bell grading scenarios');
      });
}

function editBellGrading() {
    document.getElementById('bellGradeResults').style.display = 'none';
    document.getElementById('bellGradeForm').style.display = 'block';
}

// Apply a selected scenario to persist grades
function applyBellSelection() {
    console.log('DEBUG APPLY: Function called');
    const testId = document.getElementById('bell_test_select').value;
    console.log('DEBUG APPLY: testId =', testId);
    if (!testId) { alert('Please select a test'); return; }
    
    const scenario = document.getElementById('bell_option_select').value;
    console.log('DEBUG APPLY: scenario =', scenario);
    if (!['original','linear','percentage','sqrt'].includes(scenario)) {
        alert('Please select a valid option');
        return;
    }
    
    console.log('DEBUG APPLY: Showing confirmation dialog');
    if (!confirm('This will replace student grades for this test. Continue?')) {
        console.log('DEBUG APPLY: User cancelled');
        return;
    }
    console.log('DEBUG APPLY: User confirmed');

    const targetAvgVal = document.getElementById('bell_target_avg').value;
    const targetAvg = targetAvgVal ? parseFloat(targetAvgVal) : null;
    console.log('DEBUG APPLY: targetAvg =', targetAvg);
    
    const { className, semester, subject } = getGlobalFilterValues();
    console.log('DEBUG APPLY: filters =', { className, semester, subject });

    const payload = {
        test_id: parseInt(testId),
        scenario,
        adjust_avg: true,
        target_avg: targetAvg,
        allow_over_100: false,
        boost_low: true,
        lowest_score: null,
        class_name: className || null,
        semester: semester || null,
        subject: subject || null
    };
    console.log('DEBUG APPLY: payload =', payload);
    console.log('DEBUG APPLY: About to call fetch');

    fetch('/api/apply_bell_selection', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    })
    .then(r => r.json())
    .then(data => {
        if (data.error) { alert(data.error); return; }
        alert('Test scores have been changed.');
        // Hide bell container and refresh grade matrix
        document.getElementById('bellGradeContainer').style.display = 'none';
        loadGradeMatrix();
    })
    .catch(err => {
        console.error('Apply bell selection failed', err);
        alert('Error applying bell selection');
    });
}

// Update grade dropdown when class is selected (for specialist)
function updateGradeFromClass() {
    if (teacherType !== 'specialist') return;
    
    const classSelect = document.getElementById('filter_class');
    const gradeSelect = document.getElementById('filter_grade');
    const selectedClass = classSelect.value;
    
    if (selectedClass) {
        // Get the grade from the selected class option's data-grade attribute
        const selectedOption = classSelect.options[classSelect.selectedIndex];
        const grade = selectedOption.getAttribute('data-grade');
        
        if (grade) {
            gradeSelect.value = grade;
        }
    }
}

// Update filter class options based on selected grade (for specialist)
function updateFilterClassOptions() {
    if (teacherType !== 'specialist') return;
    
    const gradeSelect = document.getElementById('filter_grade');
    const classSelect = document.getElementById('filter_class');
    const selectedGrade = gradeSelect.value;
    
    // Store current selection
    const currentSelection = classSelect.value;
    
    // Clear existing options
    classSelect.innerHTML = '<option value="">' + translations.allClasses + '</option>';
    
    if (selectedGrade && classroomsByGrade[selectedGrade]) {
        // Only show classes for the selected grade
        classroomsByGrade[selectedGrade].forEach(className => {
            const option = document.createElement('option');
            option.value = className;
            option.textContent = `${className} (${selectedGrade})`;
            option.setAttribute('data-grade', selectedGrade);
            classSelect.appendChild(option);
        });
    } else {
        // Show all classes if no grade is selected
        Object.keys(classroomsByGrade).forEach(grade => {
            classroomsByGrade[grade].forEach(className => {
                const option = document.createElement('option');
                option.value = className;
                option.textContent = `${className} (${grade})`;
                option.setAttribute('data-grade', grade);
                classSelect.appendChild(option);
            });
        });
    }
    
    // Restore selection if it's still available
    if (currentSelection) {
        const optionExists = Array.from(classSelect.options).some(option => option.value === currentSelection);
        if (optionExists) {
            classSelect.value = currentSelection;
        }
    }
}

// Load grade matrix data using global filters
function loadGradeMatrix() {
    // Get values from global filters in header
    const globalClassFilter = document.getElementById('global_class_filter');
    const globalSemesterFilter = document.getElementById('global_semester_filter');
    const subjectFilter = document.getElementById('filter_subject'); // Only for homeroom
    
    const className = globalClassFilter ? globalClassFilter.value : '';
    const semester = globalSemesterFilter ? globalSemesterFilter.value : '';
    const subject = teacherType === 'homeroom' && subjectFilter ? subjectFilter.value : '';
    
    // Check if required filters are selected
    let shouldShowMatrix = false;
    if (teacherType === 'specialist') {
        shouldShowMatrix = className !== '' && semester !== '';
    } else {
        shouldShowMatrix = semester !== '';
    }
    
    const gradeMatrixSection = document.getElementById('gradeMatrixSection');
    const noSelectionSection = document.getElementById('noSelectionSection');
    const noDataSection = document.getElementById('noDataSection');
    const actionsSection = document.getElementById('actionsSection');
    
    if (!shouldShowMatrix) {
        gradeMatrixSection.style.display = 'none';
        noDataSection.style.display = 'none';
        noSelectionSection.style.display = 'block';
        actionsSection.style.display = 'none';
        return;
    }
    
    noSelectionSection.style.display = 'none';
    actionsSection.style.display = 'block';
    
    // Build query parameters
    const params = new URLSearchParams();
    if (semester) params.append('semester', semester);
    if (className) params.append('class_name', className);
    if (subject) params.append('subject', subject);
    // Remove competency filter - always show all competencies
    
    console.log('DEBUG: Calling API with params:', params.toString());
    fetch(`/api/get_grade_matrix?${params.toString()}`)
        .then(response => {
            console.log('DEBUG: API response status:', response.status);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('DEBUG: API response data:', data);
            if (data.error) {
                console.error('API error:', data.error);
                alert('Error loading grade data: ' + data.error);
                return;
            }
            
            buildGradeMatrix(data);
        })
        .catch(error => {
            console.error('Error loading grade matrix:', error);
            if (error.message.includes('HTTP error') || error.message.includes('Failed to fetch')) {
                alert('Error loading grade data');
            }
        });
}

// Build the grade matrix table grouped by competency
function buildGradeMatrix(data) {
    const { tests, students, grades, competency_weights = {} } = data;
    
    if (tests.length === 0 || students.length === 0) {
        document.getElementById('gradeMatrixSection').style.display = 'none';
        document.getElementById('noDataSection').style.display = 'block';
        document.getElementById('noSelectionSection').style.display = 'none';
        return;
    }
    
    document.getElementById('gradeMatrixSection').style.display = 'block';
    document.getElementById('noDataSection').style.display = 'none';
    document.getElementById('noSelectionSection').style.display = 'none';
    
    const table = document.getElementById('gradeMatrix');
    const header = document.getElementById('gradeMatrixHeader');
    const body = document.getElementById('gradeMatrixBody');
    const footer = document.getElementById('gradeMatrixFooter');
    
    // Clear existing content
    header.innerHTML = '';
    body.innerHTML = '';
    footer.innerHTML = '';
    
    // Group tests by competency
    const testsByCompetency = {};
    tests.forEach(test => {
        const competency = test.competency || 'Unassigned';
        if (!testsByCompetency[competency]) {
            testsByCompetency[competency] = [];
        }
        testsByCompetency[competency].push(test);
    });
    
    const competencies = Object.keys(testsByCompetency).sort();
    // Show all competencies since we removed the competency filter
    const showAllCompetencies = true;
    
    // Build header
    const headerRow = document.createElement('tr');
    
    // Student name column
    const nameHeader = document.createElement('th');
    nameHeader.textContent = translations.studentName;
    nameHeader.style.position = 'sticky';
    nameHeader.style.left = '0';
    nameHeader.style.top = '0';
    nameHeader.style.backgroundColor = '#f8f9fa';
    nameHeader.style.zIndex = '11';
    nameHeader.style.minWidth = '150px';
    nameHeader.style.verticalAlign = 'middle';
    headerRow.appendChild(nameHeader);
    
    // For each competency, add test columns and total column
    competencies.forEach(competency => {
        const competencyTests = testsByCompetency[competency];
        
        // Individual test columns for this competency
        competencyTests.forEach(test => {
            const testHeader = document.createElement('th');
            testHeader.innerHTML = `
                <div class="text-center">
                    <div class="fw-bold">${test.test_name}</div>
                    <div class="small text-muted">${translations.weight} ${test.test_weight}%</div>
                </div>
            `;
            testHeader.style.minWidth = '100px';
            testHeader.style.backgroundColor = '#f8f9fa';
            testHeader.style.position = 'sticky';
            testHeader.style.top = '0';
            testHeader.style.zIndex = '10';
            testHeader.style.verticalAlign = 'middle';
            headerRow.appendChild(testHeader);
        });
        
        // Competency total column
        const competencyWeight = competency_weights[competency] || 0;
        const competencyTotalHeader = document.createElement('th');
        competencyTotalHeader.innerHTML = `
            <div class="text-center fw-bold" style="background-color: #e9ecef; padding: 8px;">
                <div>${translations.total} ${competency}</div>
                <div class="small text-muted">${translations.weight} ${competencyWeight}%</div>
            </div>
        `;
        competencyTotalHeader.style.minWidth = '120px';
        competencyTotalHeader.style.backgroundColor = '#e9ecef';
        competencyTotalHeader.style.verticalAlign = 'middle';
        headerRow.appendChild(competencyTotalHeader);
    });
    
    // Grand total header (only if showing all competencies)
    if (showAllCompetencies && competencies.length > 1) {
        const grandTotalHeader = document.createElement('th');
        grandTotalHeader.innerHTML = translations.grandTotal + '<br/>(' + translations.weighted + ')';
        grandTotalHeader.style.minWidth = '100px';
        grandTotalHeader.style.backgroundColor = '#e7f3ff';
        grandTotalHeader.style.textAlign = 'center';
        grandTotalHeader.style.position = 'sticky';
        grandTotalHeader.style.top = '0';
        grandTotalHeader.style.zIndex = '10';
        grandTotalHeader.style.verticalAlign = 'middle';
        headerRow.appendChild(grandTotalHeader);
    }  
    header.appendChild(headerRow);
    
    // Build test average row
    buildTestAverageRow(testsByCompetency, competencies, students, grades, header, showAllCompetencies, competency_weights);
    
    // Build body rows for each student
    students.forEach(student => {
        const row = document.createElement('tr');
        
        // Student name cell
        const nameCell = document.createElement('td');
        nameCell.textContent = `${student.first_name} ${student.last_name}`;
        nameCell.style.position = 'sticky';
        nameCell.style.left = '0';
        nameCell.style.backgroundColor = '#fff';
        nameCell.style.fontWeight = 'bold';
        nameCell.style.zIndex = '5';
        row.appendChild(nameCell);
        
        // For each competency
        competencies.forEach(competency => {
            const competencyTests = testsByCompetency[competency];
            
            // Individual test cells for this competency
            competencyTests.forEach(test => {
                const gradeCell = document.createElement('td');
                gradeCell.style.textAlign = 'center';
                
                const studentGrades = grades[student.id] || {};
                const grade = studentGrades[test.id];
                
                if (grade !== undefined && grade !== null) {
                    const percentage = ((grade / test.max_points) * 100).toFixed(1);
                    gradeCell.innerHTML = `
                        <div class="fw-bold">${grade}/${test.max_points}</div>
                        <div class="small text-muted">${percentage}%</div>
                    `;
                } else {
                    gradeCell.innerHTML = `
                        <div class="text-muted">--</div>
                        <div class="small text-muted">${translations.notGraded}</div>
                    `;
                }
                
                row.appendChild(gradeCell);
            });
            
            // Competency total cell - using weighted calculation
            const competencyTotalCell = document.createElement('td');
            competencyTotalCell.style.textAlign = 'center';
            competencyTotalCell.style.fontWeight = 'bold';
            competencyTotalCell.style.backgroundColor = '#f8f9fa';
            
            // Calculate weighted competency total: sum of (grade/max_points * weight) / sum of weights
            let weightedSum = 0;
            let totalWeights = 0;
            let hasGradedTests = false;
            
            competencyTests.forEach(test => {
                const studentGrades = grades[student.id] || {};
                const grade = studentGrades[test.id];
                
                // Only include graded tests in the calculation
                if (grade !== undefined && grade !== null) {
                    const testPercentage = grade / test.max_points;
                    weightedSum += testPercentage * test.test_weight;
                    totalWeights += test.test_weight;
                    hasGradedTests = true;
                }
            });
            
            if (hasGradedTests && totalWeights > 0) {
                const competencyPercentage = ((weightedSum / totalWeights) * 100).toFixed(1);
                competencyTotalCell.innerHTML = `<div class="fw-bold">${competencyPercentage}%</div>`;
            } else {
                competencyTotalCell.innerHTML = '<div class="text-muted">--</div>';
            }
            
            row.appendChild(competencyTotalCell);
        });
        
        // Grand total cell (only if showing all competencies)
        if (showAllCompetencies && competencies.length > 1) {
            const grandTotalCell = document.createElement('td');
            grandTotalCell.style.textAlign = 'center';
            grandTotalCell.style.fontWeight = 'bold';
            grandTotalCell.style.backgroundColor = '#e7f3ff';
            
            // Calculate weighted grand total: (Comp1% × Comp1_weight + Comp2% × Comp2_weight + ...) / (Comp1_weight + Comp2_weight + ...)
            let weightedSum = 0;
            let totalWeight = 0;
            let hasValidScores = false;
            
            competencies.forEach(competency => {
                const competencyTests = testsByCompetency[competency];
                
                // Calculate weighted competency percentage for this student (excluding ungraded tests)
                let compWeightedSum = 0;
                let compTotalWeight = 0;
                
                competencyTests.forEach(test => {
                    const studentGrades = grades[student.id] || {};
                    const grade = studentGrades[test.id];
                    if (grade !== undefined && grade !== null) {
                        const testPercentage = (grade / test.max_points) * 100;
                        compWeightedSum += testPercentage * test.test_weight;
                        compTotalWeight += test.test_weight;
                    }
                });
                
                if (compTotalWeight > 0) {
                    const competencyPercentage = compWeightedSum / compTotalWeight;
                    const competencyWeight = competency_weights[competency] || 0;
                    weightedSum += competencyPercentage * competencyWeight;
                    totalWeight += competencyWeight;
                    hasValidScores = true;
                }
            });
            
            if (hasValidScores && totalWeight > 0) {
                const grandTotal = weightedSum / totalWeight;
                grandTotalCell.innerHTML = `<div class="fw-bold">${grandTotal.toFixed(1)}%</div>`;
            } else {
                grandTotalCell.innerHTML = '<div class="text-muted">--</div>';
            }
            
            row.appendChild(grandTotalCell);
        }
        
        body.appendChild(row);
    });
    
    // Build footer with averages
    // Removed - using header average row instead
    // buildAverageRow(testsByCompetency, competencies, students, grades, footer, showAllCompetencies, competency_weights);
}

// Build average row for footer
function buildAverageRow(testsByCompetency, competencies, students, grades, footer, showAllCompetencies, competency_weights) {
    const avgRow = document.createElement('tr');
    avgRow.style.backgroundColor = '#f8f9fa';
    avgRow.style.fontWeight = 'bold';
    
    // Average label
    const avgLabel = document.createElement('td');
    avgLabel.textContent = translations.classAverage;
    avgLabel.style.position = 'sticky';
    avgLabel.style.left = '0';
    avgLabel.style.backgroundColor = '#f8f9fa';
    avgLabel.style.zIndex = '5';
    avgRow.appendChild(avgLabel);
    
    const allGrades = [];
    
    // For each competency
    competencies.forEach(competency => {
        const competencyTests = testsByCompetency[competency];
        const competencyGrades = [];
        
        // Test averages for this competency
        competencyTests.forEach(test => {
            const avgCell = document.createElement('td');
            avgCell.style.textAlign = 'center';
            
            let testTotal = 0;
            let testCount = 0;
            
            students.forEach(student => {
                const studentGrades = grades[student.id] || {};
                const grade = studentGrades[test.id];
                if (grade !== undefined && grade !== null) {
                    const percentage = (grade / test.max_points) * 100;
                    testTotal += percentage;
                    testCount++;
                    competencyGrades.push(percentage);
                    allGrades.push(percentage);
                }
            });
            
            if (testCount > 0) {
                const testAvg = testTotal / testCount;
                avgCell.innerHTML = `<div>${testAvg.toFixed(1)}%</div>`;
            } else {
                avgCell.innerHTML = '<div>--</div>';
            }
            
            avgRow.appendChild(avgCell);
        });
        
        // Competency average
        const competencyAvgCell = document.createElement('td');
        competencyAvgCell.style.textAlign = 'center';
        competencyAvgCell.style.fontWeight = 'bold';
        competencyAvgCell.style.backgroundColor = '#f8f9fa';
        
        if (competencyGrades.length > 0) {
            const competencyAvg = competencyGrades.reduce((a, b) => a + b, 0) / competencyGrades.length;
            competencyAvgCell.innerHTML = `<div>${competencyAvg.toFixed(1)}%</div>`;
        } else {
            competencyAvgCell.innerHTML = '<div>--</div>';
        }
        
        avgRow.appendChild(competencyAvgCell);
    });
    
    // Grand average (only if showing all competencies)
    if (showAllCompetencies && competencies.length > 1) {
        const grandAvgCell = document.createElement('td');
        grandAvgCell.style.textAlign = 'center';
        grandAvgCell.style.fontWeight = 'bold';
        grandAvgCell.style.backgroundColor = '#e7f3ff';
        
        // Calculate weighted average across all students
        let totalWeightedScores = 0;
        let validStudentCount = 0;
        
        students.forEach(student => {
            let weightedTotal = 0;
            let hasValidScores = false;
            
            competencies.forEach(competency => {
                const competencyTests = testsByCompetency[competency];
                let compTotalPoints = 0;
                let compTotalMaxPoints = 0;
                
                competencyTests.forEach(test => {
                    const studentGrades = grades[student.id] || {};
                    const grade = studentGrades[test.id];
                    if (grade !== undefined && grade !== null) {
                        compTotalPoints += grade;
                        compTotalMaxPoints += test.max_points;
                    } else {
                        compTotalMaxPoints += test.max_points;
                    }
                });
                
                if (compTotalMaxPoints > 0) {
                    const competencyPercentage = (compTotalPoints / compTotalMaxPoints) * 100;
                    const competencyWeight = competency_weights[competency] || 0;
                    weightedTotal += (competencyPercentage * competencyWeight) / 100;
                    hasValidScores = true;
                }
            });
            
            if (hasValidScores) {
                totalWeightedScores += weightedTotal;
                validStudentCount++;
            }
        });
        
        if (validStudentCount > 0) {
            const grandAvg = totalWeightedScores / validStudentCount;
            grandAvgCell.innerHTML = `<div>${grandAvg.toFixed(1)}%</div>`;
        } else {
            grandAvgCell.innerHTML = '<div>--</div>';
        }
        
        avgRow.appendChild(grandAvgCell);
    }
    
    footer.appendChild(avgRow);
}

// Build test average row for header section
function buildTestAverageRow(testsByCompetency, competencies, students, grades, header, showAllCompetencies, competency_weights) {
    const avgRow = document.createElement('tr');
    avgRow.style.backgroundColor = '#fff3cd';
    avgRow.style.fontWeight = 'bold';
    avgRow.style.borderBottom = '2px solid #dee2e6';
    
    // Class Average label
    const avgLabel = document.createElement('td');
    avgLabel.textContent = 'Class Average';
    avgLabel.style.position = 'sticky';
    avgLabel.style.left = '0';
    avgLabel.style.backgroundColor = '#fff3cd';
    avgLabel.style.zIndex = '11';
    avgLabel.style.fontWeight = 'bold';
    avgLabel.style.textAlign = 'left';
    avgLabel.style.paddingLeft = '8px';
    avgRow.appendChild(avgLabel);
    
    // For each competency, calculate averages for test columns and competency total
    competencies.forEach(competency => {
        const competencyTests = testsByCompetency[competency];
        
        // Individual test averages for this competency
        competencyTests.forEach(test => {
            const testAvgCell = document.createElement('td');
            testAvgCell.style.backgroundColor = '#fff3cd';
            testAvgCell.style.textAlign = 'center';
            
            // Calculate average for this test across all students
            let totalScore = 0;
            let validGradeCount = 0;
            
            students.forEach(student => {
                const studentGrades = grades[student.id] || {};
                const grade = studentGrades[test.id];
                if (grade !== undefined && grade !== null) {
                    const percentage = (grade / test.max_points) * 100;
                    totalScore += percentage;
                    validGradeCount++;
                }
            });
            
            if (validGradeCount > 0) {
                const average = totalScore / validGradeCount;
                testAvgCell.innerHTML = `<div>${average.toFixed(1)}%</div>`;
            } else {
                testAvgCell.innerHTML = '<div>--</div>';
            }
            
            avgRow.appendChild(testAvgCell);
        });
        
        // Competency average column
        const competencyAvgCell = document.createElement('td');
        competencyAvgCell.style.backgroundColor = '#fff3cd';
        competencyAvgCell.style.textAlign = 'center';
        competencyAvgCell.style.fontWeight = 'bold';
        
        // Calculate weighted average of test averages
        // Formula: (Test1_avg × Test1_weight + Test2_avg × Test2_weight + ...) / (Test1_weight + Test2_weight + ...)
        let weightedSum = 0;
        let totalWeight = 0;
        
        competencyTests.forEach(test => {
            // Calculate test average
            let testTotal = 0;
            let testCount = 0;
            
            students.forEach(student => {
                const studentGrades = grades[student.id] || {};
                const grade = studentGrades[test.id];
                if (grade !== undefined && grade !== null) {
                    const percentage = (grade / test.max_points) * 100;
                    testTotal += percentage;
                    testCount++;
                }
            });
            
            if (testCount > 0) {
                const testAvg = testTotal / testCount;
                const testWeight = test.test_weight || 0;
                weightedSum += testAvg * testWeight;
                totalWeight += testWeight;
            }
        });
        
        if (totalWeight > 0) {
            const competencyAvg = weightedSum / totalWeight;
            competencyAvgCell.innerHTML = `<div>${competencyAvg.toFixed(1)}%</div>`;
        } else {
            competencyAvgCell.innerHTML = '<div>--</div>';
        }
        
        avgRow.appendChild(competencyAvgCell);
    });
    
    // Grand total average (only if showing all competencies)
    if (showAllCompetencies && competencies.length > 1) {
        const grandAvgCell = document.createElement('td');
        grandAvgCell.style.backgroundColor = '#fff3cd';
        grandAvgCell.style.textAlign = 'center';
        grandAvgCell.style.fontWeight = 'bold';
        
        // Calculate weighted average of competency averages
        // Formula: (Comp1_avg × Comp1_weight + Comp2_avg × Comp2_weight + ...) / (Comp1_weight + Comp2_weight + ...)
        let weightedSum = 0;
        let totalWeight = 0;
        let hasValidAverages = false;
        
        competencies.forEach(competency => {
            const competencyTests = testsByCompetency[competency];
            
            // Calculate competency average (same logic as competency column)
            let compWeightedSum = 0;
            let compTotalWeight = 0;
            
            competencyTests.forEach(test => {
                // Calculate test average
                let testTotal = 0;
                let testCount = 0;
                
                students.forEach(student => {
                    const studentGrades = grades[student.id] || {};
                    const grade = studentGrades[test.id];
                    if (grade !== undefined && grade !== null) {
                        const percentage = (grade / test.max_points) * 100;
                        testTotal += percentage;
                        testCount++;
                    }
                });
                
                if (testCount > 0) {
                    const testAvg = testTotal / testCount;
                    const testWeight = test.test_weight || 0;
                    compWeightedSum += testAvg * testWeight;
                    compTotalWeight += testWeight;
                }
            });
            
            // If this competency has valid data, add to grand total
            if (compTotalWeight > 0) {
                const competencyAvg = compWeightedSum / compTotalWeight;
                const competencyWeight = competency_weights[competency] || 0;
                weightedSum += competencyAvg * competencyWeight;
                totalWeight += competencyWeight;
                hasValidAverages = true;
            }
        });
        
        if (hasValidAverages && totalWeight > 0) {
            const grandAvg = weightedSum / totalWeight;
            grandAvgCell.innerHTML = `<div>${grandAvg.toFixed(1)}%</div>`;
        } else {
            grandAvgCell.innerHTML = '<div>--</div>';
        }
        
        avgRow.appendChild(grandAvgCell);
    }
    
    header.appendChild(avgRow);
}


// Export to CSV
function exportToCSV() {
    if (!currentGradeData || currentGradeData.tests.length === 0) {
        alert(translations.noDataToExport);
        return;
    }
    
    const { tests, students, grades, competency_weights = {} } = currentGradeData;
    
    // Group tests by competency
    const testsByCompetency = {};
    tests.forEach(test => {
        const competency = test.competency || 'Unassigned';
        if (!testsByCompetency[competency]) {
            testsByCompetency[competency] = [];
        }
        testsByCompetency[competency].push(test);
    });
    
    const competencies = Object.keys(testsByCompetency).sort();
    // Show all competencies since we removed the competency filter
    const showAllCompetencies = true;
    
    // Build CSV header
    let csv = translations.studentName;
    
    // Add headers for each competency
    competencies.forEach(competency => {
        const competencyTests = testsByCompetency[competency];
        
        // Individual test columns
        competencyTests.forEach(test => {
            csv += `,"${test.test_name} (${test.max_points}pts)"`;
        });
        
        // Competency total column
        csv += `,"${translations.total} ${competency}"`;
    });
    
    // Grand total column (only if showing all competencies)
    if (showAllCompetencies && competencies.length > 1) {
        csv += ',"' + translations.grandTotal + '"';
    }
    
    csv += '\n';
    
    // Build student rows
    students.forEach(student => {
        csv += `"${student.first_name} ${student.last_name}"`;
        let grandTotalPoints = 0;
        let grandTotalMaxPoints = 0;
        
        // For each competency
        competencies.forEach(competency => {
            const competencyTests = testsByCompetency[competency];
            let competencyTotalPoints = 0;
            let competencyTotalMaxPoints = 0;
            
            // Individual test columns
            competencyTests.forEach(test => {
                const studentGrades = grades[student.id] || {};
                const grade = studentGrades[test.id];
                
                if (grade !== undefined && grade !== null) {
                    csv += `,"${grade}/${test.max_points}"`;
                    competencyTotalPoints += grade;
                    competencyTotalMaxPoints += test.max_points;
                } else {
                    csv += ',"--"';
                    competencyTotalMaxPoints += test.max_points;
                }
            });
            
            // Competency total
            if (competencyTotalMaxPoints > 0) {
                const competencyPercentage = Math.round((competencyTotalPoints / competencyTotalMaxPoints) * 100);
                csv += `,"${competencyTotalPoints}/${competencyTotalMaxPoints} (${competencyPercentage}%)"`;
            } else {
                csv += ',"--"';
            }
            
            grandTotalPoints += competencyTotalPoints;
            grandTotalMaxPoints += competencyTotalMaxPoints;
        });
        
        // Grand total (only if showing all competencies)
        if (showAllCompetencies && competencies.length > 1) {
            if (grandTotalMaxPoints > 0) {
                const grandPercentage = Math.round((grandTotalPoints / grandTotalMaxPoints) * 100);
                csv += `,"${grandTotalPoints}/${grandTotalMaxPoints} (${grandPercentage}%)"`;
            } else {
                csv += ',"--"';
            }
        }
        
        csv += '\n';
    });
    
    // Download CSV
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'grade_matrix_by_competency.csv';
    a.click();
    window.URL.revokeObjectURL(url);
}



function changeTestWeighting() {
    alert('Change Test Weighting functionality will be implemented here');
}

function dealWithAbsences() {
    alert('Deal with Absences functionality will be implemented here');
}

function reviseGrades() {
    alert('Revise Grades functionality will be implemented here');
}

// Function to populate global filters from page data
function initializeGlobalFilters() {
    const globalClassFilter = document.getElementById('global_class_filter');
    const globalSemesterFilter = document.getElementById('global_semester_filter');
    
    if (globalClassFilter && teacherType === 'specialist') {
        // Populate class dropdown
        globalClassFilter.innerHTML = '<option value="">{{ _("Select Class") }}</option>';
        Object.keys(classroomsByGrade).forEach(grade => {
            classroomsByGrade[grade].forEach(className => {
                const option = document.createElement('option');
                option.value = className;
                option.textContent = `${className} (${grade})`;
                option.setAttribute('data-grade', grade);
                globalClassFilter.appendChild(option);
            });
        });
    }
    
    if (globalSemesterFilter) {
        // Populate semester dropdown
        globalSemesterFilter.innerHTML = '<option value="">{{ _("Select Semester") }}</option>';
        const semesters = [{% for semester in semesters %}'{{ semester }}'{% if not loop.last %},{% endif %}{% endfor %}];
        semesters.forEach(semester => {
            const option = document.createElement('option');
            option.value = semester;
            option.textContent = semester;
            globalSemesterFilter.appendChild(option);
        });
    }
    
    // Load saved values
    loadGlobalFilters();
}

// Handle global filter changes
function onGlobalFiltersChanged() {
    loadGradeMatrix();
}

// Initialize page
document.addEventListener('DOMContentLoaded', function() {
    // Initialize global filters
    initializeGlobalFilters();
    
    // Load matrix based on current filter state
    loadGradeMatrix();
});
</script>

{% endblock %}
